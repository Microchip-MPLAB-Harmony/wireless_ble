<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />

<meta http-equiv="X-UA-Compatible" content="IE=EmulateIE11" /><meta name="copyright" content="(C) Copyright 2022" />
<meta name="DC.rights.owner" content="(C) Copyright 2022" />
<meta name="DC.type" content="topic" />
<meta name="DC.title" content="Uplink Credit Based Flow Control (UCBFC)" />
<meta name="DC.relation" scheme="URI" content="GUID-7A2BC74D-E714-41F0-8201-0D183867E570.html" />
<meta name="DC.format" content="XHTML" />
<meta name="DC.identifier" content="GUID-CE2B0F4F-6C2F-465A-9BD8-E19A69BA91EC" />
<meta name="DC.language" content="en-US" />
<link rel="stylesheet" type="text/css" href="stylesheets/atmel.css" />
<title>Uplink Credit Based Flow Control (UCBFC)</title>
<meta name="Microsoft.Help.Id" content="GUID-C5EAF60E-9124-427C-A0F1-F2DBE662EA92-GUID-CE2B0F4F-6C2F-465A-9BD8-E19A69BA91EC" />
<meta name="Microsoft.Help.TocParent" content="GUID-C5EAF60E-9124-427C-A0F1-F2DBE662EA92-GUID-7A2BC74D-E714-41F0-8201-0D183867E570" />
<meta name="Microsoft.Help.TocOrder" content="1" />
<meta name="Microsoft.Help.Locale" content="en-US" />
<meta name="Microsoft.Help.TopicLocale" content="en-US" />
<meta name="Microsoft.Help.DisplayVersion" content="MPLAB Harmony wireless_ble Reference 1.0 03/2022" />
<script language="javascript">
       
       if (window.parent.location.protocol != 'file:') {
				document.addEventListener('click', function(e) {
				    if (e.target) {
               if (e.target.nodeName == "A" ) {
                    if (!e.target.target) {
                      e.preventDefault();
                      e.stopPropagation();
                              
                      var origUrl = window.parent.location.href.substr(0, window.parent.location.href.indexOf("?"));
                      if (origUrl.length === 0) {
                          origUrl = window.parent.location.href;
                      }
                      var href= e.target.getAttribute("href");
                      var parts = href.split("#");
          
                      var url = "";
                      if (parts.length == 2 ) {
                        if (!parts[0].length) {
                            url = window.parent.location.search.replace('?','')
                        } else {
                            url = parts[0].replace('.html','');
                        }
                      } else {
                        url = parts[0].replace('.html','');
                      }

                      if (parts.length == 2) {
                          url += "#" + parts[1];
                      }
    
                      window.parent.location.href = origUrl + "?" + url;

                      return false;
                    }
               }
            }
				});
			}

		</script><script language="javascript">
         
         function copyContent(content, button) {
         
            var textArea = document.createElement("textarea");
            
            // Place in the top-left corner of screen regardless of scroll position.
            textArea.style.position = 'fixed';
            textArea.style.top = 0;
            textArea.style.left = 0;
            
            // Ensure it has a small width and height. Setting to 1px / 1em
            // doesn't work as this gives a negative w/h on some browsers.
            textArea.style.width = '2em';
            textArea.style.height = '2em';
            
            // We don't need padding, reducing the size if it does flash render.
            textArea.style.padding = 0;
            
            // Clean up any borders.
            textArea.style.border = 'none';
            textArea.style.outline = 'none';
            textArea.style.boxShadow = 'none';
            
            // Avoid flash of the white box if rendered for any reason.
            textArea.style.background = 'transparent';
            
            textArea.value = content;
            
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
               var successful = document.execCommand('copy');
               var msg = successful ? 'successful' : 'unsuccessful';
               if (!button.classList.contains("copied")){
                  button.textContent = "Copied";
                  button.classList.add("copied");
                  setTimeout(function(){
                     button.textContent = "Copy";
                     button.classList.remove("copied");
                  },1000);
               }
            } catch (err) {
               console.log('Oops, unable to copy');
            }
            
            document.body.removeChild(textArea);
         }
         
         function cpy(id, button) {
            var element = document.getElementById(id);
            var content = element.getAttribute("content");
            
            copyContent(content, button);
         }
         
         document.addEventListener("DOMContentLoaded", function(event) {
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.style.position = "relative";
               var copy = document.createElement("button");
               copy.textContent = "Copy";
               copy.setAttribute("class", "copy-code");
               
               var content = elem.textContent;
               
               copy.addEventListener("click", function(){
                  copyContent(content, copy);
               });
               
               elem.addEventListener("mouseenter", function(evt){
                  elem.prepend(copy);
               });
            });
            
            document.querySelectorAll(".codeblock").forEach(function(elem) {
               elem.addEventListener("mouseleave", function(evt){
                  document.querySelector(".copy-code").remove();
               });
            });
         });
         
      </script><script language="javascript">
          
          // Add the MathML namespace to html
          var html = document.getElementsByTagName("html")[0],
          head = document.getElementsByTagName("head")[0];
          
          var mathJax = document.createElement("script");
          mathJax.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML";
          head.appendChild(mathJax);
          
          html.setAttribute("xmlns:m","http://www.w3.org/1998/Math/MathML");
          
          function inIframe() { try { return window.self !== window.top; } catch (e) { return true; } }
          
          if (!inIframe()) { 
          
          var Default = "index.html?GUID-CE2B0F4F-6C2F-465A-9BD8-E19A69BA91EC"; 
          
          var displaylocation = "value" + window.location.href;
          
          var GUIDS = displaylocation.split('GUID');          
          
          if (displaylocation.indexOf('#GUID') != -1) {            
          var First = GUIDS[1].split('.html');  
          if (GUIDS[3]){First = GUIDS[2].split('.html');}
          if (GUIDS[4]){First = GUIDS[3].split('.html');}
          if (GUIDS[5]){First = GUIDS[4].split('.html');}
          
          var Second = GUIDS[2].split('#');   
          if (GUIDS[3]){Second = GUIDS[3].split('#');}
          if (GUIDS[4]){Second = GUIDS[4].split('#');}
          if (GUIDS[5]){Second = GUIDS[5].split('#');}
          
          Default = "index.html?" + "GUID" + First[0] + "GUID" + Second[0];     
          }                    
          window.top.location = Default;
          }       
          
        </script><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /><style xml:space="">
        
          button.copy-code{
            display:none;
            padding:0.7em 1.4em;
            margin:0 0.3em 0.3em 0;
            border-radius:0.15em;
            box-sizing: border-box;
            text-decoration:none;
            font-family:'Roboto',sans-serif;
            text-transform:uppercase;
            font-weight:400;
            color:#FFFFFF;
            background-color:#9c9c9c;
            box-shadow:inset 0 -0.6em 0 -0.35em rgba(0,0,0,0.17);
            text-align:center;
            position:relative;
            border: 0;
            float: right;
            border-radius: .5em;
            cursor: pointer;
          }
          button.copy-code:active{
            top:0.1em;
          }
          
          pre:hover button.copy-code{
            display: inline-block !important;
          }
          button.copy-code.copied {
            cursor: default !important;
          }
          
          
          @media all and (max-width:30em){
            button.copy-code{
              display:block;
              margin:0.4em auto;
            }
          }
        
        
      </style><link rel="stylesheet" type="text/css" href="syntax-highlight.css" /></head>
<body id="GUID-CE2B0F4F-6C2F-465A-9BD8-E19A69BA91EC">

<h1 class="title topictitle1" id="GUID-CE2B0F4F-6C2F-465A-9BD8-E19A69BA91EC__GUID-B3D0A834-596A-44A7-BEB7-AD4FB4CA604F">Uplink Credit Based Flow Control
        (UCBFC)</h1>

<div class="body"><p class="shortdesc"></p>

<p class="p">The procedure is used by a Transparent Client to enable Uplink Credit Based Flow Control on the
            Transparent Server. Once it is enabled, Server role can only send data to Client while
            the credit count is greater than zero.</p>

        <p class="p">When enable Uplink Credit Based Flow Control, Client shall write “Uplink Credit Based
            Flow Control Enable” opcode (0x15) to the Transparent Control Point on Transparent
            Server. There are given Credit value parameter in this opcode. Transparent Server will
            check the credit count to know how many packets can be uploaded to the Transparent
            Client by performing the notify operation to TUD Characteristic handle. The Credit count
            will be decreased by the number of ATT packet sending by Transparent Server. Transparent
            Server can send data only while the credit count is greater than zero. Transparent
            Client shall return the credit value to Transparent Server after the received data has
            been processed completed.</p>

        <p class="p">When enable Credit Based Flow Control Uplink and available credits on Client shall be
            written to the Transparent Control Point on Transparent Server. Transparent Server will
            check the number of credit to know how many available data list can transmit to the
            Transparent Client. The number of credit is decrease by the list of data sending by
            Transparent Server. Transparent Server is able to send data only while the number of
            credit is non-zero. Transparent Client shall return the credit to Transparent Server
            after the received data has been processed completed.</p>

        <div class="p"><img class="image" id="GUID-CE2B0F4F-6C2F-465A-9BD8-E19A69BA91EC__IMAGE_QR2_PSN_WSB" src="GUID-57939AB4-6EA5-4725-9F5F-2DF4237D7FFC-low.png" height="450" width="416" /><div class="fig equation-figure fignone" id="GUID-CE2B0F4F-6C2F-465A-9BD8-E19A69BA91EC__GUID-41730EA2-79F5-4A4A-97EF-E61DFD23F8E6"><span class="desc figdesc">Example MSC of Uplink Credit Based Flow Control usage. Initial credit number
                    is 8 and credits-given threshold is 5.</span>
                
            </div>
</div>

</div>

<div class="related-links">
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a class="link" href="GUID-7A2BC74D-E714-41F0-8201-0D183867E570.html">Transparent Control Point Characteristic Behavior</a></div>
</div>
</div></body>
</html>